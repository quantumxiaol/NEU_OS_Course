#四 页面置换算法

实验简述

编程实现FIFO和LRU算法。

程序涉及一个父进程和两个子进程。父进程使用rand()函数随机产生若干随机数，经过处理后，存于一数组Acess_Series[]中，作为内存页面访问的序列。

两个子进程根据这个访问序列，分别采用FIFO和LRU两种不同的页面置换算法对内存页面进行调度。

要求：

每个子进程应能反映出页面置换的过程，并统计页面置换算法的命中或缺页情况。

设缺页的次数为diseffect。总的页面访问次数为total_instruction。 

缺页率 = disaffect/total_instruction 

命中率 = 1- disaffect/total_instruction 

将为进程分配的内存页面数mframe作为程序的参数，通过多次运行程序，说明FIFO算法存在的Belady现象。

实验内容

基础点

给出了随机数的页面访问序列，并通过两个子进程展示出了FIFO和LRU执行过程，和内存中已分配页面的变化过程。

扩展点

由于在c语言中不便于实现动态数组，使用了宏定义frame_num来记录进程分配到的最大内存页面数量，便于修改观察Belady现象。

能够展示出页面的调入调出和缺页次数。

在算法结束后可以计算并显示出缺页率和命中率。

观察到了FIFO的Belady现象。

数据结构及说明

存放页面访问序列的数组 (Acess_Series[total_instruction]) 
用一个结构数组M_Frame[]记录为进程分配的内存页面的使用情况。在M_Frame[]中还可记载各页面进入内存或被访问的先后顺序（如可使M_Frame[0]总是最先进入或最久未被访问的页面）。 
   struct one_frame { 
          int page_no; 
          char flag; 
   }; 
   struct one_frame M_Frame[frame_num]; 

回答问题： 

1.父进程空间与子进程空间的关系。 

2.通过完成实验，根据你的体会，阐述虚拟存储器的原理。 

3.说明FIFO算法存在的Belady现象。  

父进程先创建子进程p1，再执行子进程p1。子进程p1执行结束父进程继续执行，创建子进程p2，再执行子进程p2，父进程等待子进程执行结束继续执行，程序结束。

虚拟存储的基本原理为：在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页或段调入到内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的页或段调出保存在外存上，从而腾出空间存放将要装入的程序以及将要调入的页或段。只需程序所需的一部分在内存就可执行

虚拟存储器可以分为三类：页式、段式和段页式。本实验我们主要学习页式虚拟存储器。

在页式虚拟存储器中通过把主存空间和程序空间都机械等分成固定大小的页（页面大小随机器而定，一般为4kB到4MB），按页顺序编号，用相应的映像表机构来指明该程序的某页是否已经装入主存。若已经装入主存，则应同时指明其在主存中所处的位置；如果未装入主存，则去辅存中调页，并建立起程序空间和实存空间的地址映像关系。

程序执行时通过查映像表将程序地址（虚拟地址）变换成实际主存地址（物理地址）再访问主存。


改变宏定义值，观察缺页率的变化。发现采用FIFO算法时，有时会出现分配的物理页数增加，缺页率反而提高的异常现象。

Belady现象的原因：

FIFI算法的置换特征与进程访问内存的动态特征矛盾，与置换算法的目标不一致，因此，被他置换出去的页面不一定是进程不访问的（可能将进程会访问的页置换出去了）。
