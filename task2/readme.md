# 实验一：进程状态

## 题目
模拟进程状态转换及其PCB的变化

## 目的
自行编制模拟程序，通过形象化的状态显示，使学生理解进程的概念、进程之间的状态转换及其所带来的PCB内容 、组织的变化，理解进程与其PCB间的一一对应关系。

## 要求
设计并实现一个模拟进程状态转换及其相应PCB组织结构变化的程序；

独立设计、编写、调试程序；
程序界面应能反映出在模拟条件下，进程之间状态转换及其对应的PCB组织的变化。
进程的状态模型（三状态、五状态、七状态或其它）可自行选择
代码书写要规范，要适当地加入注释；
鼓励在实验中加入新的观点或想法，并加以实现；
认真进行预习，完成预习报告；
实验完成后，要认真总结，完成实验报告。


### 进程与PCB
进程是程序的一次执行活动。进程对应程序的执行，进程是动态产生的：创建、运行、消亡，进程在其生命周期内，在三种基本状态之间转换。进程 = 代码段 + 数据段 + PCB。
程序是进程的不可缺少的组成部分；如果一个程序段允许被共享，则它应该是可重入的，或纯代码段；
数据是进程处理的对象；
进程控制块是进程的控制结构，包含了进程的描述信息、控制信息和资源信息以及现场保护区，是进程的唯一标识，系统通过PCB管理和控制进程。

PCB结构的全部或部分常驻内存；
PCB随进程的创建而填写，随进程的撤消而释放；
系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志；
进程与PCB是一一对应的。

状态设计需求
在计算机中处于运行状态的任何一个程序都是一个进程，一个进程拥有内存、CPU时间等一系列资源。
创建状态（Created）： OS 已完成为创建一进程所必要的工作，已构造了进程标识符；已创建了管理进程所需的表格。但还没有允许执行该进程 (尚未同意)。
因为资源有限，OS所需的关于该进程的信息保存在主存中的进程表中，但进程自身还未进入主存，也没有为与这个程序相关的数据分配空间，程序保留在辅存中；
在批处理系统中，提交新作业；为新登录用户创建进程；请求打印的进程创建打印进程，请求进程可以继续处理其他事情。
终止状态（Terminated）：终止后进程移入该状态，它不再有执行资格，表格和其它信息暂时保留，实用程序为了分析性能和利用率，可能要提取程序的历史信息
就绪状态（Ready） ：一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态。当调度给其CPU时，立即可以运行。“万事俱备，只欠东风”。位于“就绪队列”中
执行状态（Running） ：进程占有了包括CPU在内的全部资源，并在CPU上运行
等待状态（Blocked） ：阻塞态、挂起态、封锁态、冻结态、睡眠态。指进程因等待某种事件的发生而暂时不能运行的状态（即使CPU空闲，该进程也不可运行）。处于等待态的进程位于等待队列中
挂起状态：把一个进程从内存转到外存


## 初步的程序设计思路
我计划实现一个五状态转移的PCB模拟程序，暂不考虑内存分配，只涉及进程优先级。
创建PCB结构体。
struct PCB{
    int time;//所需时间片
    int Pid;//进程ID
    int Ppri;//进程优先级
};

我计划用vector实现模拟队列，用sort函数实现优先级排序，vector和queue的区别：vector可以随机访问，queue只能从头部删除，尾部添加。vector的push_back()和pop_back()函数实现队列的入队和出队。vector的insert()和erase()函数实现队列的入队和出队。

## 初步的程序源代码
使用bool greaterPCB(const PCB& s1,const PCB s2)比较进程的优先级。

int Occurs()将阻塞态转变为就绪态，主要是判断阻塞态队列非空和按照优先级重新排序。

int Create()手动创建进程。主要有进程号的自动分配。

int Dispatch()将就绪态转变为运行态，运行态空时往运行态添加一个进程，需要判断运行态队列为空和比较运行态和就绪态的优先级。

int Realse()结束并释放进程，添加到终止状态队列。

int Timeout()将运行态转为就绪态，通过进程时间判断是否结束。

int Wait()将运行态转为阻塞态。

int Output()时刻打印队列信息。
